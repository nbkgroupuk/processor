#!/usr/bin/env python3
# iso_listener_patch.py — safe patch script for processor iso_listener

import argparse, shutil, time, pathlib, sys
SRC = pathlib.Path("/app/app/iso_listener.py")
BACKUP_DIR = pathlib.Path("/app/app")
PATCH = '''# tolerant iso_listener.py (generated by patch script)
import asyncio, logging, json, re, struct
LOG = logging.getLogger("processor.iso_listener")
LOG.addHandler(logging.StreamHandler())
LOG.setLevel(logging.INFO)
MAX_FRAME = 10 * 1024 * 1024
try:
    from app.iso_codec import unpack_iso, pack_iso
except Exception:
    unpack_iso = None
    pack_iso = None
async def async_read_frame(reader):
    raw_len = await reader.readexactly(4)
    ln = int.from_bytes(raw_len, "big")
    if ln <= 0 or ln > MAX_FRAME:
        raise ValueError("invalid frame length")
    return await reader.readexactly(ln)
async def handle_conn(reader, writer):
    peer = writer.get_extra_info("peername")
    LOG.info("Client connected: %s", peer)
    try:
        while True:
            try:
                payload = await async_read_frame(reader)
            except asyncio.IncompleteReadError:
                LOG.info("Client disconnected (incomplete): %s", peer)
                break
            except Exception as e:
                LOG.error("Read frame error: %s", e)
                break
            if unpack_iso:
                try:
                    unpacked = unpack_iso(payload)
                    if isinstance(unpacked, dict):
                        mti = unpacked.get("mti") or ""
                        fields = unpacked.get("fields", {})
                    else:
                        mti, fields = unpacked
                    LOG.info("Received ISO MTI=%s fields=%s", mti, fields)
                    resp = pack_iso("0210", {"39":"00", **({k:str(v) for k,v in fields.items() if k in (11,41)})})
                    writer.write(resp)
                    await writer.drain()
                    continue
                except Exception as e:
                    LOG.warning("ISO unpack failed: %s", e)
            try:
                text = payload.decode("utf-8", errors="replace").strip()
                clean = re.sub(r'^[0-9]{4}', '', text).strip()
                req = json.loads(clean)
                LOG.info("Parsed JSON fallback: %s", req)
                inner = req.get("fields", {})
                resp_fields = {"39":"00"}
                if inner.get("authCode"):
                    resp_fields["38"] = inner["authCode"]
                if inner.get("11"):
                    resp_fields["11"] = inner["11"]
                if inner.get("41"):
                    resp_fields["41"] = inner["41"]
                resp_json = "0210" + json.dumps({"fields": resp_fields}, separators=(",", ":"))
                rb = resp_json.encode("utf-8")
                writer.write(struct.pack(">I", len(rb)) + rb)
                await writer.drain()
                continue
            except Exception as e:
                LOG.error("Fallback JSON failed: %s", e)
                err = "0210" + json.dumps({"fields":{"39":"96"}})
                eb = err.encode("utf-8")
                writer.write(struct.pack(">I", len(eb)) + eb)
                await writer.drain()
                continue
    finally:
        try:
            writer.close()
            await writer.wait_closed()
        except Exception:
            pass
        LOG.info("Client disconnected: %s", peer)
async def start_server(host='0.0.0.0', port=9000):
    server = await asyncio.start_server(handle_conn, host, port)
    LOG.info("ISO listener started %s:%d", host, port)
    async with server:
        await server.serve_forever()
if __name__ == '__main__':
    import argparse
    p = argparse.ArgumentParser()
    p.add_argument("--host", default="0.0.0.0")
    p.add_argument("--port", type=int, default=9000)
    a = p.parse_args()
    try:
        asyncio.run(start_server(a.host, a.port))
    except Exception as e:
        LOG.exception("server crashed: %s", e)
'''
def apply_patch():
    if not SRC.exists():
        print("ERROR: target file not found:", SRC)
        return 2
    ts = int(time.time())
    bak = BACKUP_DIR / f"iso_listener.py.bak_{ts}"
    shutil.copy2(SRC, bak)
    SRC.write_text(PATCH)
    print("✅ Patched", SRC, "and backup saved at", bak)
    return 0
def main():
    p = argparse.ArgumentParser()
    p.add_argument("--apply", action="store_true")
    args = p.parse_args()
    if args.apply:
        sys.exit(apply_patch())
    else:
        print("Dry-run. To apply inside container run with --apply")
if __name__ == '__main__':
    main()
